<rule name="git_branch_and_commit_style">
  ## Branch Naming
  Always name branches using the format:
    <type>/<short-description>

  - <type> must be one of:
      feat  → new feature
      fix   → bug fix
      refactor → code refactoring
      chore → tooling, CI/CD, dependencies, configs
      docs  → documentation only
      test  → tests only
      perf  → performance improvements

  - <short-description>:
      * All lowercase
      * Words separated by hyphens
      * Concise but descriptive (3–5 words ideally)
      * No issue numbers, dates, or uppercase letters

  Examples:
    feat/login-button
    fix/crash-on-empty-upload
    refactor/db-query-builder
    chore/update-ci-workflow
    docs/api-authentication-guide

  ## Commit Messages
  Follow Conventional Commits format:
    <type>(scope): <summary>

    [body]

    [footer]

  - The <type> in the commit message must match the <type> in the branch name.
  - Use the <short-description> from the branch to decide on the <scope> or
    guide the <summary>.
  - Subject line ≤ 50 chars, imperative mood.
  - Wrap body at 72 chars.
  - Body explains "what + why", not just the diff.
  - Footer for BREAKING CHANGE or issue refs.

  ## Examples
  Branch: feat/login-button
  Commit: feat(ui): add login button component

  Branch: fix/crash-on-empty-upload
  Commit: fix(upload): prevent crash on empty file uploads

  Branch: chore/update-ci-workflow
  Commit: chore(ci): update GitHub Actions workflow to cache deps
</rule>

<rule name="prettier_formatting_standards">
# Prettier Code Formatting Standards

All code must follow Prettier formatting standards for consistency and professional appearance.

## HTML
- 2-space indentation
- Self-closing tags with trailing slash (e.g., `<meta charset="UTF-8" />`)
- Multi-line attributes: each attribute on separate line when exceeding line length
- Opening tag bracket `>` stays at end of last attribute line (not on separate line)
- Block comments properly indented with `<!-- ... -->` format
- No trailing spaces, proper line endings

## JavaScript/TypeScript  
- 2-space indentation
- Semicolons required
- Trailing commas in objects and arrays
- Single quotes for strings (except when avoiding escapes)
- Line length limit: 80-100 characters
- Proper spacing around operators and function parameters

## CSS
- 2-space indentation
- Properties sorted logically (not alphabetically)
- Trailing semicolons required
- Space after colons in property declarations
- Consistent spacing in selectors

## Configuration
- Use Prettier defaults where possible
- Override only when necessary for project requirements
- Ensure all team members use same Prettier version and config
</rule>

<rule name="claude_editing_rules_js_ts">
# Claude Editing Rules (JS/TS)

## General
- Prefer clarity over cleverness. Small, readable functions.
- Apply Prettier-compatible formatting (2 spaces, LF, trailing commas, semicolons).
- Use strict equality (===/!==). No implicit coercion.
- Prefer const; use let only when reassigned. Never use var.
- Remove dead code and unused imports/vars (unless prefixed with _).
- No TODOs without owner and date: // TODO(bob, YYYY-MM-DD): message

## Commenting (TypeScript) - Based on song-data.ts Example

### Module-Level Documentation
- **Start with action**: Describe what the module DOES (e.g., "Reads X and exports Y")
- **Use proper TSDoc tags**:
  - `@remarks` for data flow, design decisions, architecture notes
  - `@see` for cross-references to consuming modules
  - `@beta` for future considerations (without external dependencies)

Example:
```typescript
/**
 * Reads songs.json and exports a strongly-typed array of 80s songs for display in the music table.
 * 
 * @remarks
 * Data flow: songs.json → Song[] type validation → exported songs array.
 * 
 * @see {@link script.ts} - Primary consumer for table rendering/sorting
 */
```

### Interface/Type Documentation
- **Lead with purpose**: What contract does this define?
- **Document design choices** in `@remarks` when valuable
- **Property comments**: Single-line, placed BEFORE the property
  - Include `@example` inline for clarity
  - Note constraints TypeScript can't enforce

Example:
```typescript
export interface Song {
  /** Song title @example "Billie Jean" */
  name: string;
  /** Release year (1980-1989, not enforced at compile time) */
  year: number;
}
```

### Variable/Export Documentation
- **Be specific**: "Strongly-typed array" not "collection"
- **Explain validation** that TypeScript provides
- **Note limitations** clearly (what's NOT validated)

Example:
```typescript
/**
 * Strongly-typed array of Song objects imported from JSON.
 * 
 * @remarks
 * TypeScript catches structural mismatches at compile time:
 * - Missing field: "Property 'name' is missing in type..."
 * 
 * Does NOT validate business rules (e.g., year range).
 */
export const songs: Song[] = songData;
```

### General Rules
- **NEVER describe WHAT** - the code shows that
- **ALWAYS explain WHY** - design decisions, constraints, trade-offs
- **Use concrete examples** - actual values, actual error messages
- **One example per comment** for brevity
- **Proper comment placement** - TSDoc before declarations, not after
- **No redundant comments** like `// Import data` or `/** Song structure */`

### TSDoc Tag Usage
- `@remarks` - Detailed explanations, design rationale, data flow
- `@example` - Inline examples with actual values
- `@see` - Cross-references (use at root level, not nested)
- `@beta` - Future considerations or experimental features
- Avoid `@param/@returns` in TypeScript (types are self-documenting)

## Naming & Files
- camelCase for vars/functions; PascalCase for classes/types; UPPER_SNAKE for const enums.
- File names: kebab-case for modules; keep types near usage or in *.d.ts when shared.

## Arrays of Object Literals
- Provide a TypeScript interface or type definition for the schema.
- Keep object keys in stable order; one object per line with trailing commas.
- If there are business constraints (e.g., allowed ranges), document them in comments and add runtime validation when feasible.

## TypeScript Type Discipline
- Avoid any. Narrow types; prefer union/literal types and branded types.
- Use TypeScript interfaces and types instead of JSDoc type annotations.
- Enable strict mode and enforce compile-time type safety.
- Document business constraints in comments that TypeScript can't enforce.

## Error Handling
- Don't swallow errors. Either handle explicitly or propagate with context.
- Add error messages that include actionable context (ids, counts, thresholds).

## Output Requirements (Claude)
- Ensure code is formatted as Prettier would output.
- Ensure it passes the repo ESLint config.
- Maintain/insert JSDoc on public APIs and non-trivial modules.
- Preserve existing comments; improve them only if clarity increases.
- Return only changed files' contents; no extra prose unless asked.

## Example Templates (TypeScript)
- Interface with business constraints:
  /**
   * Song data structure for the 80s music application.
   * 
   * Note: TypeScript validates structure but not value constraints.
   * Runtime validation needed for business rules.
   */
  export interface Song {
    /** Song title - should be non-empty but not enforced at compile time */
    name: string;
    /** Artist name - should be non-empty but not enforced at compile time */  
    artist: string;
    /** Release year - should be 1980-1989 but only number type enforced */
    year: number;
  }

- Complex function JSDoc:
  /**
   * <what/why in one sentence, business logic focus>
   * @example
   *   const result = complexFunction(data);
   */

# See CLAUDE.md for rationale and extended examples.
</rule>
