<rule name="git_branch_and_commit_style">
  ## Branch Naming
  Always name branches using the format:
    <type>/<short-description>

  - <type> must be one of:
      feat  → new feature
      fix   → bug fix
      refactor → code refactoring
      chore → tooling, CI/CD, dependencies, configs
      docs  → documentation only
      test  → tests only
      perf  → performance improvements

  - <short-description>:
      * All lowercase
      * Words separated by hyphens
      * Concise but descriptive (3–5 words ideally)
      * No issue numbers, dates, or uppercase letters

  Examples:
    feat/login-button
    fix/crash-on-empty-upload
    refactor/db-query-builder
    chore/update-ci-workflow
    docs/api-authentication-guide

  ## Commit Messages
  Follow Conventional Commits format:
    <type>(scope): <summary>

    [body]

    [footer]

  - The <type> in the commit message must match the <type> in the branch name.
  - Use the <short-description> from the branch to decide on the <scope> or
    guide the <summary>.
  - Subject line ≤ 50 chars, imperative mood.
  - Wrap body at 72 chars.
  - Body explains "what + why", not just the diff.
  - Footer for BREAKING CHANGE or issue refs.

  ## Examples
  Branch: feat/login-button
  Commit: feat(ui): add login button component

  Branch: fix/crash-on-empty-upload
  Commit: fix(upload): prevent crash on empty file uploads

  Branch: chore/update-ci-workflow
  Commit: chore(ci): update GitHub Actions workflow to cache deps
</rule>

<rule name="prettier_formatting_standards">
# Prettier Code Formatting Standards

All code must follow Prettier formatting standards for consistency and professional appearance.

## HTML
- 2-space indentation
- Self-closing tags with trailing slash (e.g., `<meta charset="UTF-8" />`)
- Multi-line attributes: each attribute on separate line when exceeding line length
- Opening tag bracket `>` stays at end of last attribute line (not on separate line)
- Block comments properly indented with `<!-- ... -->` format
- No trailing spaces, proper line endings

## JavaScript/TypeScript  
- 2-space indentation
- Semicolons required
- Trailing commas in objects and arrays
- Single quotes for strings (except when avoiding escapes)
- Line length limit: 80-100 characters
- Proper spacing around operators and function parameters

## CSS
- 2-space indentation
- Properties sorted logically (not alphabetically)
- Trailing semicolons required
- Space after colons in property declarations
- Consistent spacing in selectors

## Configuration
- Use Prettier defaults where possible
- Override only when necessary for project requirements
- Ensure all team members use same Prettier version and config
</rule>

<rule name="claude_editing_rules_js_ts">
# Claude Editing Rules (JS/TS)

## General
- Prefer clarity over cleverness. Small, readable functions.
- Apply Prettier-compatible formatting (2 spaces, LF, trailing commas, semicolons).
- Use strict equality (===/!==). No implicit coercion.
- Prefer const; use let only when reassigned. Never use var.
- Remove dead code and unused imports/vars (unless prefixed with _).
- No TODOs without owner and date: // TODO(bob, YYYY-MM-DD): message

## Commenting (TypeScript)

- Use TSDoc (`/** ... */`) for:
  - Module/file headers: purpose, invariants, assumptions, ownership, and dependencies
  - Business logic explanation with concrete examples where helpful
  - Complex algorithms or non-obvious implementation decisions
  - Constraints that TypeScript cannot enforce (e.g., value ranges, business rules)

- NEVER write comments that simply describe *what* the code does — the code shows that
- Comments should explain *why*, capture constraints, trade-offs, or provide clarifying examples

- Avoid redundant comments, such as:
  - `// Import song data` above an import
  - `/** Song structure */` above a Song interface
  - Comments that restate variable or function names

- Prefer `@example` in TSDoc for illustrative code snippets:
  ```ts
  /**
   * @example
   * ```ts
   * import { songs } from './song-data';
   * console.log(songs[0].artist); // "Michael Jackson"
   * ```
   */
  ```

- Include concrete examples in inline comments when they add clarity:
  - Use ONE example per comment for brevity: `// e.g., "Billie Jean"`
  - Good: `// Must be 1980-1989 (not enforced by TypeScript)`
  - Good: `// e.g., "Billie Jean"`
  - Good: `// E.g., renaming 'name' to 'namex' causes compile error`
  - Bad: `// e.g., "Billie Jean", "Sweet Child O' Mine", "Thriller"` (too many)
  - Bad: `// This is a string` or `// Import the data`

- Use `//` single-line comments for:
  - Brief constraints or examples: `// e.g., "Billie Jean"`
  - TODOs with ownership: `// TODO(dave, 2025-01-15): Migrate to API`
  - Temporary debugging notes (remove before commit)

- When referencing potential errors, include the actual error message:
  - Good: `// Causes: "Type '{ namex: string; }[]' is not assignable to type 'Song[]'"`
  - Bad: `// This will cause a type error`

- Avoid TSDoc @param/@returns in TypeScript (types are self-documenting)
- Link issues/PRDs in comments when relevant

## Naming & Files
- camelCase for vars/functions; PascalCase for classes/types; UPPER_SNAKE for const enums.
- File names: kebab-case for modules; keep types near usage or in *.d.ts when shared.

## Arrays of Object Literals
- Provide a TypeScript interface or type definition for the schema.
- Keep object keys in stable order; one object per line with trailing commas.
- If there are business constraints (e.g., allowed ranges), document them in comments and add runtime validation when feasible.

## TypeScript Type Discipline
- Avoid any. Narrow types; prefer union/literal types and branded types.
- Use TypeScript interfaces and types instead of JSDoc type annotations.
- Enable strict mode and enforce compile-time type safety.
- Document business constraints in comments that TypeScript can't enforce.

## Error Handling
- Don't swallow errors. Either handle explicitly or propagate with context.
- Add error messages that include actionable context (ids, counts, thresholds).

## Output Requirements (Claude)
- Ensure code is formatted as Prettier would output.
- Ensure it passes the repo ESLint config.
- Maintain/insert JSDoc on public APIs and non-trivial modules.
- Preserve existing comments; improve them only if clarity increases.
- Return only changed files' contents; no extra prose unless asked.

## Example Templates (TypeScript)
- Interface with business constraints:
  /**
   * Song data structure for the 80s music application.
   * 
   * Note: TypeScript validates structure but not value constraints.
   * Runtime validation needed for business rules.
   */
  export interface Song {
    /** Song title - should be non-empty but not enforced at compile time */
    name: string;
    /** Artist name - should be non-empty but not enforced at compile time */  
    artist: string;
    /** Release year - should be 1980-1989 but only number type enforced */
    year: number;
  }

- Complex function JSDoc:
  /**
   * <what/why in one sentence, business logic focus>
   * @example
   *   const result = complexFunction(data);
   */

# See CLAUDE.md for rationale and extended examples.
</rule>
